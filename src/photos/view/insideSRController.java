package photos.view;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ListView;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import photos.models.Album;
import photos.models.Photo;
import photos.models.User;
import photos.models.Users;

/**
 * insideSRController class provides the functionality for the user with the
 * resulting photo results from the preceding photos search. Attributes include
 * an ObservableList of resulting images, an ArrayList of Strings that are
 * comprised of the associated attributes of a Photo object, a String,
 * currentUser which tracks the current user of that session, an ArrayList of
 * images, an ObservableList of images, an Album, currentAlbum which tracks the
 * album that has been opened, String currentTag which represents the selected
 * tag to be deleted, and Photo object currPhoto, which represents which photo
 * has been selected to be modified by the user. Methods include initialize(),
 * which populates an ArrayList of photos with the photos that are generated by
 * the search, sets the first photo in the album or a different photo that the
 * user has selected to populate an ImageView in the center of the scene with
 * its corresponding attributes populating a ListView, and populates an hbox at
 * the bottom of the scene with all of the photos in the album with their
 * corresponding captions, to be scrolled through, handleChange() which is
 * triggered by the clicking of the available buttons that enable the user to
 * modify the photo's caption, tags, or location, loadWindow() which redirects
 * the user to the location with which it is called, updatePhotos() which
 * updates the Photos List and ObservableLists so that scene is always updated
 * with the most relevant information provided by the user, and formatUploads()
 * which modifies the String path associated with an uploaded photo so that it
 * may be correctly read for further use in the application.
 * 
 * @author Ahmed Elgazzar, Samantha Ames
 *
 */
public class insideSRController {

	@FXML
	Button logoutBtn;
	@FXML
	Button quitBtn;
	@FXML
	Button returnBtn;
	@FXML
	Button saveBtn;

	// list view
	@FXML
	ListView<String> photoDetail;

	// main image view
	@FXML
	ImageView mainImage;

	// hbox
	@FXML
	HBox hboxImage;

	// scrollpane
	@FXML
	ScrollPane scroll;

	private List<Image> images = new ArrayList<>();
//	private Album sampleAlbum = new Album("Sample Album", null);
	private ObservableList<Image> obsImage;
	private ObservableList<String> obsInfo;

	public ArrayList<Photo> photos = new ArrayList<Photo>();
	public ArrayList<String> photoInfo;

	public static String currentUser;
	public static Album currentAlbum; // load from AlbumPageController
	public String currentTag = "";
	Photo currPhoto = null;
	public static User currUser;

	/**
	 * initialize() void method populates an hbox from an ObservableList of images
	 * of photos from the search results, with a ListView of corresponding
	 * information for the selected Photo of its attributes, and available buttons
	 * in the right pane.
	 * 
	 * @throws IOException
	 */

	public void initialize() throws IOException {
		photoInfo = new ArrayList<String>();
		System.out.println("current Album: " + currentAlbum.getPhotos());

		if (currentAlbum.getPhotos() == null) {
			currentAlbum.setPhotos(new ArrayList<Photo>());

		}
		photos = currentAlbum.getPhotos();
//		if(photos == null) {
//			currentAlbum.setPhotos(new ArrayList<Photo>());
//			p
//		}

		if (photos != null) {
			if (photos.size() > 0) {
				String caption = (photos.get(0).getCaption() != null) ? (photos.get(0).getCaption()) : ("[No Caption]");
				photoInfo.add(caption);
				String dateTaken = photos.get(0).getDateTaken();
				photoInfo.add(dateTaken);
				if (photos.get(0).getTags() != null) {
					for (int j = 0; j < photos.get(0).getTags().size(); j++) {
						String photoTag = photos.get(0).getTags().get(j).toString();
						photoInfo.add(photoTag);
					}
				}

			}
		}

		obsInfo = FXCollections.observableArrayList(photoInfo);
		if (photos != null) {
			for (int i = 0; i < photos.size(); i++) {
				if (photos.get(i).getPath().toString() != null) {
					System.out.println(photos.get(i).getPath().toString());
					Image image = new Image("file:" + photos.get(i).getPath().toString());
					Image image2 = null;
					try {
						image2 = new Image(photos.get(i).getPath().toString());
					} catch (IllegalArgumentException ex) {
						image2 = image;
					}

					if (image2.getWidth() > image.getWidth()) {
						image = image2;
					}
					images.add(image);

				}

			}

		}

		obsImage = FXCollections.observableArrayList(images);

		// display first image in album
		if (obsImage.size() > 0) {
			mainImage.setImage(obsImage.get(0));
			mainImage.setPreserveRatio(true);
			currPhoto = photos.get(0);

		}

		hboxImage.setSpacing(10);

//		obsInfo.clear();
//		photoDetail.getItems().clear();
//		photoInfo.clear();
//		String caption = photos.get(0).getCaption();
//		photoInfo.add(caption);
//		String dateTaken = photos.get(0).getDateTaken();
//		photoInfo.add(dateTaken);
//		for (int k = 0; k < photos.get(0).getTags().size(); k++) {
//			String photoTag = photos.get(0).getTags().get(k).toString();
//			photoInfo.add(photoTag);
//			
//		}
//		
//		obsInfo = FXCollections.observableArrayList(photoInfo);

		photoDetail.setItems(obsInfo);

		photoDetail.getSelectionModel().selectedItemProperty().addListener((obs, oldVal, newVal) -> {
			currentTag = newVal;
			System.out.println(newVal);
		});

		// populate arraylist of images to hbox
		for (int i = 0; i < obsImage.size(); i++) {
			ImageView imageView = new ImageView();
			TextArea textArea = new TextArea();
			textArea.setMaxSize(150, 30);
			textArea.setMinSize(150, 30);
			textArea.setEditable(false);

			imageView.setOnMouseClicked(event -> {
				mainImage.setImage(imageView.getImage());
				System.out.println(imageView.getImage().getUrl());
				ArrayList<Photo> photos1 = currentAlbum.getPhotos();
				for (int j = 0; j < photos1.size(); j++) {

					if (imageView.getImage().getUrl().contains(photos1.get(j).getPath())) {
						System.out.println("print");
						currPhoto = photos.get(j);
						obsInfo.clear();
						photoDetail.getItems().clear();
						photoInfo.clear();
						String caption1 = (photos.get(j).getCaption() != null) ? (photos.get(j).getCaption())
								: ("[No Caption]");

						photoInfo.add(caption1);
						String dateTaken1 = photos1.get(j).getDateTaken();
						photoInfo.add(dateTaken1);
						if (photos1.get(j).getTags() != null) {
							for (int k = 0; k < photos1.get(j).getTags().size(); k++) {
								String photoTag = photos1.get(j).getTags().get(k).toString();
								photoInfo.add(photoTag);

							}

						}

						obsInfo = FXCollections.observableArrayList(photoInfo);

						photoDetail.setItems(obsInfo);
					}
				}
			});

			imageView.setImage(obsImage.get(i));
			imageView.setPreserveRatio(true);
			imageView.setFitHeight(200);
			imageView.setFitWidth(300);

			String caption = (photos.get(i).getCaption() != null) ? (photos.get(i).getCaption()) : ("[No Caption]");
			textArea.setText(caption);

			hboxImage.getChildren().add(imageView);
			hboxImage.getChildren().add(textArea);

//			System.out.println(obsImage.get(i));
			System.out.println("size: " + photos.size());
		}

	}

	/**
	 * handleChange() void method takes an ActionEvent that is triggered by the
	 * following buttons: saveBtn allows the user to save the resulting photos as a
	 * newly created album, returnBtn redirects the user back to the Album Page they
	 * were at previously, logoutBtn saves any changes made by the user in the
	 * session while redirected to the Login Page, and quitBtn saves any changes
	 * made during the session by the user while closing the application.
	 * 
	 * @param e ActionEvent that is triggered by the clicking of one of the
	 *          available buttons
	 * @throws IOException
	 */
	public void handleChange(ActionEvent e) throws IOException {

		ArrayList<Photo> photos = currentAlbum.getPhotos();
//		System.out.println("photos: " + photos);
		Button btnType = (Button) e.getSource();

		// add photo to album
		if (btnType == saveBtn) {
			System.out.println("save clicked");
			if (currUser != null && photos.size() > 0) {
				ArrayList<Album> userAlbums = currUser.getAlbums();
				int numOfSRAlbums = 0;
				for (int i = 0; i < userAlbums.size(); i++) {
					if (userAlbums.get(i).getName().contains("Search Results")) {
						numOfSRAlbums++;
					}
				}
				Album newAlbum = new Album("Search Results " + (numOfSRAlbums + 1), photos);
				currUser.getAlbums().add(newAlbum);
				Users.save();
				((Node) e.getSource()).getScene().getWindow().hide();
				loadWindow("/photos/view/AlbumPage.fxml", "Album Select");
				return;

			} else {
				System.out.println("User is Null");
			}

		} else if (btnType == returnBtn) {
			Users.save();
			((Node) e.getSource()).getScene().getWindow().hide();
			loadWindow("/photos/view/search.fxml", "Search Page");

		}

		// logout from application, return to login
		else if (btnType == logoutBtn) {
			((Node) e.getSource()).getScene().getWindow().hide();
			Parent root = FXMLLoader.load(getClass().getResource("/photos/view/login.fxml"));
			Logout.logout(root);

		}

		// quit application
		else if (btnType == quitBtn) {
			Users.save();
			Platform.exit();

		}
	}

	/**
	 * loadWindow() void method takes String parameters for the location of
	 * re-direction and the title of the page that will be loaded.
	 * 
	 * @param location path of FXML file for re-direction destination
	 * @param title    title for page of re-direction
	 * @throws IOException
	 */

	private void loadWindow(String location, String title) throws IOException {

		Parent root = FXMLLoader.load(getClass().getResource(location));
		Scene scene = new Scene(root);
		Stage stage = new Stage(StageStyle.DECORATED);
		stage.setScene(scene);
		stage.setTitle(title);
		stage.show();
	}

	/**
	 * updatePhotos() void method updates the Photos ArrayLists and ObservableLists
	 * so that the inside album page is displaying the most updated information for
	 * the user, including the photos displayed in the hbox, and any corresponding
	 * captions for the hbox or photo details for the ListView.
	 * 
	 */

	public void updatePhotos() {

		hboxImage.getChildren().setAll();
		if (photos.size() == 0) {

			obsInfo.clear();
			photoDetail.getItems().clear();
			photoInfo.clear();

		}

		// populate arraylist of images to hbox
		for (int i = 0; i < obsImage.size(); i++) {
			ImageView imageView = new ImageView();
			TextArea textArea = new TextArea();
			textArea.setMaxSize(150, 30);
			textArea.setMinSize(150, 30);
			textArea.setEditable(false);

			imageView.setImage(obsImage.get(i));
			imageView.setPreserveRatio(true);
			imageView.setFitHeight(200);
			imageView.setFitWidth(300);

//			System.out.println(photos.size());
//			System.out.println(obsImage.size());

			if (i == 0 && photos.size() > 0) {

				mainImage.setImage(imageView.getImage());
				obsInfo.clear();
				photoDetail.getItems().clear();
				photoInfo.clear();
//				System.out.println("obs info" + obsInfo.size());

				String caption = (photos.get(0).getCaption() != null) ? (photos.get(0).getCaption()) : ("[No Caption]");

				photoInfo.add(caption);
				String dateTaken = photos.get(0).getDateTaken().toString();
				System.out.println("DT" + dateTaken);

				photoInfo.add(dateTaken);
				if (photos.get(0).getTags() != null) {
					for (int k = 0; k < photos.get(0).getTags().size(); k++) {
						String photoTag = photos.get(0).getTags().get(k).toString();
						photoInfo.add(photoTag);
					}
				}
				obsInfo = FXCollections.observableArrayList(photoInfo);

				photoDetail.setItems(obsInfo);

				if (photos.get(i).getCaption() != null) {
					textArea.setText(photos.get(i).getCaption());
				} else {
					textArea.setText("[No Caption]");
				}

			}
			System.out.println("Photos Size: " + photos.size());

			hboxImage.getChildren().add(imageView);
			hboxImage.getChildren().add(textArea);

//			System.out.println(obsImage.get(i));

			imageView.setOnMouseClicked(event -> {
				mainImage.setImage(imageView.getImage());
//				System.out.println(imageView.getImage().getUrl());
				boolean found = false;
				for (int j = 0; j < photos.size(); j++) {
					if (imageView.getImage().getUrl().contains(photos.get(j).getPath())) {
						found = true;
						currPhoto = photos.get(j);
//						System.out.println("print");
						obsInfo.clear();
						photoDetail.getItems().clear();
						photoInfo.clear();
//						System.out.println("obs info" + obsInfo.size());
						String caption = (photos.get(j).getCaption() != null) ? (photos.get(j).getCaption())
								: ("[No Caption]");

						photoInfo.add(caption);
						String dateTaken = photos.get(j).getDateTaken().toString();
//						System.out.println("DT" + dateTaken);

						photoInfo.add(dateTaken);
						if (photos.get(j).getTags() != null) {
							for (int k = 0; k < photos.get(j).getTags().size(); k++) {
								String photoTag = photos.get(j).getTags().get(k).toString();
								photoInfo.add(photoTag);
							}
						}
						obsInfo = FXCollections.observableArrayList(photoInfo);

						photoDetail.setItems(obsInfo);
					}
				}
				if (!found) {
					obsInfo.clear();
					photoDetail.getItems().clear();
					photoInfo.clear();
					System.out.println("obs info" + obsInfo.size());

					obsInfo = FXCollections.observableArrayList(photoInfo);

					photoDetail.setItems(obsInfo);
				}
			});
		}
		currentAlbum.setPhotos(photos);
		for (int i = 0; i < Users.users.size(); i++) {
			if (Users.users.get(i).getUsername().equals(currentUser)) {
				ArrayList<Album> userAlbums = Users.users.get(i).getAlbums();
				for (int j = 0; j < userAlbums.size(); j++) {
					if (userAlbums.get(j).equals(currentAlbum)) {
//						System.out.println("found Album: " + userAlbums.get(j).getNumOfPhotos());
					}

				}
			}
		}
	}

	/**
	 * formatUploads() method takes a String and identifies any characters that may
	 * be encoded differently when uploaded from files to be used as paths in the
	 * application and modifies the String path associated with an uploaded photo so
	 * that it may be correctly read for further use in the application.
	 * 
	 * @param upload String from uploaded photo
	 * @return String path to be correctly read for further use in Photos objects
	 */
	public String formatUploads(String upload) {

		String formattedFile = upload;

		if (upload.indexOf('?') != -1) {

			formattedFile = upload.toString().replace("?", "%3F");

		} else if (upload.indexOf(' ') != -1) {

			formattedFile = upload.toString().replace(" ", "%20");
		} else if (upload.indexOf('"') != -1) {

			formattedFile = upload.toString().replace("\"", "%22");
		} else if (upload.indexOf('<') != -1) {

			formattedFile = upload.toString().replace("<", "%3C");
		} else if (upload.indexOf('>') != -1) {

			formattedFile = upload.toString().replace(">", "%3E");
		} else if (upload.indexOf('#') != -1) {

			formattedFile = upload.toString().replace("#", "%23");
		} else if (upload.indexOf('%') != -1) {

			formattedFile = upload.toString().replace("%", "%25");
		} else if (upload.indexOf('{') != -1) {

			formattedFile = upload.toString().replace("{", "%7B");
		} else if (upload.indexOf('}') != -1) {

			formattedFile = upload.toString().replace("}", "%7D");
		} else if (upload.indexOf('|') != -1) {

			formattedFile = upload.toString().replace("|", "%7C");
		} else if (upload.indexOf('\\') != -1) {

			formattedFile = upload.toString().replace("\\", "%5C");
		} else if (upload.indexOf('^') != -1) {

			formattedFile = upload.toString().replace("^", "%5E");
		} else if (upload.indexOf('[') != -1) {

			formattedFile = upload.toString().replace("[", "%5B");
		} else if (upload.indexOf(']') != -1) {

			formattedFile = upload.toString().replace("]", "%5D");
		} else if (upload.indexOf('`') != -1) {

			formattedFile = upload.toString().replace("`", "%60");
		} else
			return formattedFile;

		return formattedFile;

	}
}